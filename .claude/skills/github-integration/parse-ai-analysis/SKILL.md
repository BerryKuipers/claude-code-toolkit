---
name: parse-ai-analysis
description: Parse GitHub AI analysis comment sections for architectural alignment, technical feasibility, implementation suggestions, and testing strategy
---

# Parse AI Analysis

## Purpose

Extract structured data from GitHub AI issue analysis comments generated by github-actions bot for use in architecture planning and implementation.

## When to Use

- After fetching issue with `fetch-github-issue-analysis` skill
- When AI analysis found in issue comments
- During conductor Phase 1 (architecture planning)
- When extracting specific sections for delegation

## AI Analysis Format

The AI analysis comment contains these sections:

```markdown
# AI Issue Analysis

## Architectural Alignment
[How this issue aligns with current architecture]

## Technical Feasibility
[Assessment of implementation difficulty and approach]

## Implementation Suggestions
[Specific implementation recommendations]

## Files/Components Affected
[List of files that will need changes]

## Testing Strategy
[Recommended testing approach]

## Dependencies
[Related issues or features]

## Estimated Complexity
[Simple/Medium/Complex assessment]
```

## Instructions

### Step 1: Validate Input

```bash
AI_ANALYSIS=$1  # Full AI analysis comment text

if [ -z "$AI_ANALYSIS" ]; then
  echo "❌ Error: No AI analysis provided"
  exit 1
fi

# Check if contains expected heading
if ! echo "$AI_ANALYSIS" | grep -q "AI Issue Analysis"; then
  echo "⚠️ Warning: Unexpected format - may not be AI analysis"
fi
```

### Step 2: Extract Architectural Alignment

```bash
# Extract section between "## Architectural Alignment" and next "##"
ARCH_ALIGNMENT=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Architectural Alignment/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d')

if [ -n "$ARCH_ALIGNMENT" ]; then
  echo "✅ Architectural Alignment: $(echo "$ARCH_ALIGNMENT" | wc -l) lines"
else
  echo "⚠️ Architectural Alignment section not found"
  ARCH_ALIGNMENT="Not provided"
fi
```

### Step 3: Extract Technical Feasibility

```bash
TECH_FEASIBILITY=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Technical Feasibility/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d')

if [ -n "$TECH_FEASIBILITY" ]; then
  echo "✅ Technical Feasibility: $(echo "$TECH_FEASIBILITY" | wc -l) lines"
else
  TECH_FEASIBILITY="Not provided"
fi
```

### Step 4: Extract Implementation Suggestions

```bash
IMPL_SUGGESTIONS=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Implementation Suggestions/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d')

if [ -n "$IMPL_SUGGESTIONS" ]; then
  echo "✅ Implementation Suggestions: $(echo "$IMPL_SUGGESTIONS" | wc -l) lines"
else
  IMPL_SUGGESTIONS="Not provided"
fi
```

### Step 5: Extract Files/Components Affected

```bash
FILES_AFFECTED=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Files\/Components/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d')

# Convert to array
if [ -n "$FILES_AFFECTED" ]; then
  FILES_ARRAY=$(echo "$FILES_AFFECTED" | \
    grep -oP '`[^`]+`' | \
    sed 's/`//g' | \
    jq -R -s -c 'split("\n") | map(select(length > 0))')

  echo "✅ Files Affected: $(echo "$FILES_ARRAY" | jq '. | length') files"
else
  FILES_ARRAY="[]"
fi
```

### Step 6: Extract Testing Strategy

```bash
TESTING_STRATEGY=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Testing Strategy/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d')

if [ -n "$TESTING_STRATEGY" ]; then
  echo "✅ Testing Strategy: $(echo "$TESTING_STRATEGY" | wc -l) lines"
else
  TESTING_STRATEGY="Not provided"
fi
```

### Step 7: Extract Dependencies

```bash
DEPENDENCIES=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Dependencies/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d')

# Extract issue numbers
if [ -n "$DEPENDENCIES" ]; then
  DEPS_ARRAY=$(echo "$DEPENDENCIES" | \
    grep -oP '#\d+' | \
    sed 's/#//' | \
    jq -R -s -c 'split("\n") | map(select(length > 0) | tonumber)')
else
  DEPS_ARRAY="[]"
fi
```

### Step 8: Extract Complexity

```bash
COMPLEXITY=$(echo "$AI_ANALYSIS" | \
  sed -n '/## Estimated Complexity/,/^## /p' | \
  sed '$d' | \
  sed '1d' | \
  sed '/^$/d' | \
  grep -oP '(Simple|Medium|Complex)' | \
  head -1)

if [ -z "$COMPLEXITY" ]; then
  COMPLEXITY="Unknown"
fi

echo "✅ Complexity: $COMPLEXITY"
```

### Step 9: Return Structured Output

```json
{
  "status": "success",
  "sections": {
    "architecturalAlignment": "$ARCH_ALIGNMENT",
    "technicalFeasibility": "$TECH_FEASIBILITY",
    "implementationSuggestions": "$IMPL_SUGGESTIONS",
    "filesAffected": $FILES_ARRAY,
    "testingStrategy": "$TESTING_STRATEGY",
    "dependencies": $DEPS_ARRAY,
    "complexity": "$COMPLEXITY"
  },
  "raw": "$AI_ANALYSIS"
}
```

## Output Format

### Complete Parse

```json
{
  "status": "success",
  "sections": {
    "architecturalAlignment": "Aligns with component-based architecture. Requires state management updates.",
    "technicalFeasibility": "High - uses existing React patterns. No new dependencies required.",
    "implementationSuggestions": "1. Add darkMode to WorldContext\n2. Create DarkModeToggle component\n3. Persist to localStorage",
    "filesAffected": [
      "src/context/WorldContext.tsx",
      "src/components/Settings/DarkModeToggle.tsx",
      "src/styles/theme.ts"
    ],
    "testingStrategy": "Unit tests for toggle component, integration tests for persistence, visual regression tests",
    "dependencies": [135, 140],
    "complexity": "Medium"
  }
}
```

### Partial Data

```json
{
  "status": "partial",
  "sections": {
    "architecturalAlignment": "Provided",
    "technicalFeasibility": "Not provided",
    "implementationSuggestions": "Provided",
    "filesAffected": [],
    "testingStrategy": "Not provided",
    "dependencies": [],
    "complexity": "Unknown"
  },
  "warnings": ["Technical Feasibility section missing", "No files specified"]
}
```

## Integration with Conductor

Used in conductor Phase 1 after fetching issue:

```markdown
### Phase 1: Issue Discovery and Planning

**Step 1: Issue Selection**

Use `fetch-github-issue-analysis` to get issue + AI analysis

If AI analysis found:
  Use `parse-ai-analysis` skill to extract structured sections:
  - Input: AI analysis comment text
  - Output: Structured sections

  **Provide to architect agent**:
  - Architectural alignment insights
  - Technical feasibility assessment
  - Suggested implementation approach

  **Provide to implementation agent**:
  - Implementation suggestions
  - Files that need changes

  **Provide to test planning**:
  - Testing strategy recommendations
```

## Related Skills

- `fetch-github-issue-analysis` - Get AI analysis from GitHub
- Architect agent - Uses architectural alignment data
- Implementation agent - Uses implementation suggestions

## Error Handling

### Missing Sections

```json
{
  "status": "warning",
  "message": "Some sections missing",
  "missingSections": ["Technical Feasibility", "Testing Strategy"]
}
```

### Invalid Format

```json
{
  "status": "error",
  "error": "AI analysis format unrecognized",
  "suggestion": "Manually review comment"
}
```

## Best Practices

1. **Always validate input** - Check for expected format
2. **Handle missing sections** - AI analysis may be incomplete
3. **Extract issue numbers** - Parse dependencies for workflow planning
4. **Preserve raw text** - Include original for reference
5. **Return structured data** - JSON for easy consumption

## Notes

- AI analysis format may vary by issue type
- Not all sections may be present
- Section headings must match exactly for parsing
- Use raw text as fallback if parsing fails
